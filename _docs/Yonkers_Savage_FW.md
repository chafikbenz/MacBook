# Yonkers

## Header

* uint32_t version? = 0x02
* uint32_t header_size = 72 (0x48)
* uint32_t
* uint32_t
* uint32_t
* uint32_t = number of rows (5)
* uint32_t = BE size of row
* uint8_t[32] = SHA 256 Hash
* uint32_t
* uint32_t = offset / next haeder size
* uint32_t = flags

## Rows

```
58670F7E 9ED5F03D 3EC7CACC BBA68416 85C25FCE 99B237F4 697D6D1D 6CAA77C9 625D4201 5ABD2C08 C842F790 339D8DB1 16D93FD4 CB3B684D EA4F4B64 C035A2B2
BE0795C0 6D8A51FA 9CE8357B 72D99B4C 876FCFAA 89547183 2D34E19C 342FA221 9D4DA49B 65AB7152 240603D9 5C2163D7 D05E63F9 CCAD81FD C1962266 FBCCF1A6

ECFF16D1 D5C975E2 693EAB14 25EEBB84 EE97AF77 C5177BF4 1974D0E5 0D131398 6468E2DA 9E54E221 FFD2F7B1 D5F57893 A364B8C3 58524897 41E23852 D41AEE1A
57439C94 BADB07C1 EBC8EE55 99B72986 896EB6FF AAA87F3C 1039334B 61F3BB70 D4086F7D 7D847E61 E390908B B533D115 5ECCC216 5D866AD7 2BA7B872 F196AA26

5C958306 6A342A66 CAA09143 99C76A36 A7767B0F 7A36C1D9 C977A7D6 AFA6CC52 234D0939 2BDC8B52 28D13845 1B0EEB20 57DB1BEB D3719D71 23D133DA CF165D17
F8C19A07 6C9F304A 448E4A55 0E4B3606 74F4442C CFFF4F71 7D0EE4F2 18D35E70 F22A4482 910F57EA A2307EB7 B04C1498 0B368591 BC4BAF3A F0B60BC4 57D22E5E

1AABD176 07A69A5E 76BC659C 34BDA9BE 153E0DC3 6F189EC0 3EA03A8A 7641D6BA D6E1D91A 6B4F0495 A331631F 1FA23697 BC49098C 37354EB7 E79591E5 FAF6AEDF
29B745DA 788530D8 628E2599 B200FF17 CE644D49 8CC9295B 0D7240BD CEF57648 25C51027 CDD44274 DD647CED E056E2CA 210EAFB5 578C2539 DBDE92B3 1D2A53FE

DFA064EB 3CC843CA D6EB9610 0D9580B3 27E06098 EE468A45 BC7B753F C0AE990E 085E1678 14A6B2E4 46CC14B8 F8EE8FB1 48EAC12C 48D49435 A1D87B41 56A652C4
8D641979 36B93A75 BFAA8035 77B50F5D D5CA34BF 5208ED4B CB1B7C19 80303F0D 28C18589 729C3D05 30532471 CB0F49A7 7A96657D 528B7544 C3D467AD 5F81922B
```

```c
#define SHA1_HASH_LENGTH 0x20

typdef struct {
    uint32_t version = 2;
    uint32_t header_size = 0x48;
    uint32_t firmware_total_size;
    uint32_t
    uint32_t
    uint32_t rows; // Guess: based on data being a multiple of this
    uint32_t row_size_be;
    char* hash[SHA1_HASH_LENGTH]; // Not hash of data stream or full file, perhaps check after patch?
    uint32_t
    uint32_t data_offset = 0;
    uint32_t flags;
} yonkers_firmware_header_t

// Basically a SWAG: theroy 0xA0 is not aligned by 16 bytes - likely row data
typedef struct {
    char* uuid[16];
    char* data[0x90]
} yonkers_patch_t;
```